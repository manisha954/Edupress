"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/compressorjs";
exports.ids = ["vendor-chunks/compressorjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/compressorjs/dist/compressor.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/compressorjs/dist/compressor.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Compressor)\n/* harmony export */ });\n/*!\n * Compressor.js v1.2.1\n * https://fengyuanchen.github.io/compressorjs\n *\n * Copyright 2018-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2023-02-28T14:09:41.732Z\n */\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar canvasToBlob = {exports: {}};\n\n/*\n * JavaScript Canvas to Blob\n * https://github.com/blueimp/JavaScript-Canvas-to-Blob\n *\n * Copyright 2012, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on stackoverflow user Stoive's code snippet:\n * http://stackoverflow.com/q/4998908\n */\n(function (module) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  (function (window) {\n\n    var CanvasPrototype = window.HTMLCanvasElement && window.HTMLCanvasElement.prototype;\n    var hasBlobConstructor = window.Blob && function () {\n      try {\n        return Boolean(new Blob());\n      } catch (e) {\n        return false;\n      }\n    }();\n    var hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && function () {\n      try {\n        return new Blob([new Uint8Array(100)]).size === 100;\n      } catch (e) {\n        return false;\n      }\n    }();\n    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n    var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;\n    var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob && window.ArrayBuffer && window.Uint8Array && function (dataURI) {\n      var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i, bb;\n      // Parse the dataURI components as per RFC 2397\n      matches = dataURI.match(dataURIPattern);\n      if (!matches) {\n        throw new Error('invalid data URI');\n      }\n      // Default to text/plain;charset=US-ASCII\n      mediaType = matches[2] ? matches[1] : 'text/plain' + (matches[3] || ';charset=US-ASCII');\n      isBase64 = !!matches[4];\n      dataString = dataURI.slice(matches[0].length);\n      if (isBase64) {\n        // Convert base64 to raw binary data held in a string:\n        byteString = atob(dataString);\n      } else {\n        // Convert base64/URLEncoded data component to raw binary:\n        byteString = decodeURIComponent(dataString);\n      }\n      // Write the bytes of the string to an ArrayBuffer:\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      for (i = 0; i < byteString.length; i += 1) {\n        intArray[i] = byteString.charCodeAt(i);\n      }\n      // Write the ArrayBuffer (or ArrayBufferView) to a blob:\n      if (hasBlobConstructor) {\n        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {\n          type: mediaType\n        });\n      }\n      bb = new BlobBuilder();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mediaType);\n    };\n    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {\n      if (CanvasPrototype.mozGetAsFile) {\n        CanvasPrototype.toBlob = function (callback, type, quality) {\n          var self = this;\n          setTimeout(function () {\n            if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {\n              callback(dataURLtoBlob(self.toDataURL(type, quality)));\n            } else {\n              callback(self.mozGetAsFile('blob', type));\n            }\n          });\n        };\n      } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {\n        if (CanvasPrototype.msToBlob) {\n          CanvasPrototype.toBlob = function (callback, type, quality) {\n            var self = this;\n            setTimeout(function () {\n              if ((type && type !== 'image/png' || quality) && CanvasPrototype.toDataURL && dataURLtoBlob) {\n                callback(dataURLtoBlob(self.toDataURL(type, quality)));\n              } else {\n                callback(self.msToBlob(type));\n              }\n            });\n          };\n        } else {\n          CanvasPrototype.toBlob = function (callback, type, quality) {\n            var self = this;\n            setTimeout(function () {\n              callback(dataURLtoBlob(self.toDataURL(type, quality)));\n            });\n          };\n        }\n      }\n    }\n    if (module.exports) {\n      module.exports = dataURLtoBlob;\n    } else {\n      window.dataURLtoBlob = dataURLtoBlob;\n    }\n  })(window);\n})(canvasToBlob);\nvar toBlob = canvasToBlob.exports;\n\nvar isBlob = function isBlob(value) {\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n  return value instanceof Blob || Object.prototype.toString.call(value) === '[object Blob]';\n};\n\nvar DEFAULTS = {\n  /**\n   * Indicates if output the original image instead of the compressed one\n   * when the size of the compressed image is greater than the original one's\n   * @type {boolean}\n   */\n  strict: true,\n  /**\n   * Indicates if read the image's Exif Orientation information,\n   * and then rotate or flip the image automatically.\n   * @type {boolean}\n   */\n  checkOrientation: true,\n  /**\n   * Indicates if retain the image's Exif information after compressed.\n   * @type {boolean}\n  */\n  retainExif: false,\n  /**\n   * The max width of the output image.\n   * @type {number}\n   */\n  maxWidth: Infinity,\n  /**\n   * The max height of the output image.\n   * @type {number}\n   */\n  maxHeight: Infinity,\n  /**\n   * The min width of the output image.\n   * @type {number}\n   */\n  minWidth: 0,\n  /**\n   * The min height of the output image.\n   * @type {number}\n   */\n  minHeight: 0,\n  /**\n   * The width of the output image.\n   * If not specified, the natural width of the source image will be used.\n   * @type {number}\n   */\n  width: undefined,\n  /**\n   * The height of the output image.\n   * If not specified, the natural height of the source image will be used.\n   * @type {number}\n   */\n  height: undefined,\n  /**\n   * Sets how the size of the image should be resized to the container\n   * specified by the `width` and `height` options.\n   * @type {string}\n   */\n  resize: 'none',\n  /**\n   * The quality of the output image.\n   * It must be a number between `0` and `1`,\n   * and only available for `image/jpeg` and `image/webp` images.\n   * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.\n   * @type {number}\n   */\n  quality: 0.8,\n  /**\n   * The mime type of the output image.\n   * By default, the original mime type of the source image file will be used.\n   * @type {string}\n   */\n  mimeType: 'auto',\n  /**\n   * Files whose file type is included in this list,\n   * and whose file size exceeds the `convertSize` value will be converted to JPEGs.\n   * @type {string｜Array}\n   */\n  convertTypes: ['image/png'],\n  /**\n   * PNG files over this size (5 MB by default) will be converted to JPEGs.\n   * To disable this, just set the value to `Infinity`.\n   * @type {number}\n   */\n  convertSize: 5000000,\n  /**\n   * The hook function to execute before draw the image into the canvas for compression.\n   * @type {Function}\n   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.\n   * @param {HTMLCanvasElement} canvas - The canvas for compression.\n   * @example\n   * function (context, canvas) {\n   *   context.fillStyle = '#fff';\n   * }\n   */\n  beforeDraw: null,\n  /**\n   * The hook function to execute after drew the image into the canvas for compression.\n   * @type {Function}\n   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.\n   * @param {HTMLCanvasElement} canvas - The canvas for compression.\n   * @example\n   * function (context, canvas) {\n   *   context.filter = 'grayscale(100%)';\n   * }\n   */\n  drew: null,\n  /**\n   * The hook function to execute when success to compress the image.\n   * @type {Function}\n   * @param {File} file - The compressed image File object.\n   * @example\n   * function (file) {\n   *   console.log(file);\n   * }\n   */\n  success: null,\n  /**\n   * The hook function to execute when fail to compress the image.\n   * @type {Function}\n   * @param {Error} err - An Error object.\n   * @example\n   * function (err) {\n   *   console.log(err.message);\n   * }\n   */\n  error: null\n};\n\nvar IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nvar WINDOW = IS_BROWSER ? window : {};\n\n/**\n * Check if the given value is a positive number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n */\nvar isPositiveNumber = function isPositiveNumber(value) {\n  return value > 0 && value < Infinity;\n};\nvar slice = Array.prototype.slice;\n\n/**\n * Convert array-like or iterable object to an array.\n * @param {*} value - The value to convert.\n * @returns {Array} Returns a new array.\n */\nfunction toArray(value) {\n  return Array.from ? Array.from(value) : slice.call(value);\n}\nvar REGEXP_IMAGE_TYPE = /^image\\/.+$/;\n\n/**\n * Check if the given value is a mime type of image.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given is a mime type of image, else `false`.\n */\nfunction isImageType(value) {\n  return REGEXP_IMAGE_TYPE.test(value);\n}\n\n/**\n * Convert image type to extension.\n * @param {string} value - The image type to convert.\n * @returns {boolean} Returns the image extension.\n */\nfunction imageTypeToExtension(value) {\n  var extension = isImageType(value) ? value.substr(6) : '';\n  if (extension === 'jpeg') {\n    extension = 'jpg';\n  }\n  return \".\".concat(extension);\n}\nvar fromCharCode = String.fromCharCode;\n\n/**\n * Get string from char code in data view.\n * @param {DataView} dataView - The data view for read.\n * @param {number} start - The start index.\n * @param {number} length - The read length.\n * @returns {string} The read result.\n */\nfunction getStringFromCharCode(dataView, start, length) {\n  var str = '';\n  var i;\n  length += start;\n  for (i = start; i < length; i += 1) {\n    str += fromCharCode(dataView.getUint8(i));\n  }\n  return str;\n}\nvar btoa = WINDOW.btoa;\n\n/**\n * Transform array buffer to Data URL.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {string} mimeType - The mime type of the Data URL.\n * @returns {string} The result Data URL.\n */\nfunction arrayBufferToDataURL(arrayBuffer, mimeType) {\n  var chunks = [];\n  var chunkSize = 8192;\n  var uint8 = new Uint8Array(arrayBuffer);\n  while (uint8.length > 0) {\n    // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n    // eslint-disable-next-line prefer-spread\n    chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n    uint8 = uint8.subarray(chunkSize);\n  }\n  return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\n}\n\n/**\n * Get orientation value from given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {number} The read orientation value.\n */\nfunction resetAndGetOrientation(arrayBuffer) {\n  var dataView = new DataView(arrayBuffer);\n  var orientation;\n\n  // Ignores range error when the image does not have correct Exif information\n  try {\n    var littleEndian;\n    var app1Start;\n    var ifdStart;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      var length = dataView.byteLength;\n      var offset = 2;\n      while (offset + 1 < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n        offset += 1;\n      }\n    }\n    if (app1Start) {\n      var exifIDCode = app1Start + 4;\n      var tiffOffset = app1Start + 10;\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        var endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n    if (ifdStart) {\n      var _length = dataView.getUint16(ifdStart, littleEndian);\n      var _offset;\n      var i;\n      for (i = 0; i < _length; i += 1) {\n        _offset = ifdStart + i * 12 + 2;\n        if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {\n          // 8 is the offset of the current tag's value\n          _offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(_offset, littleEndian);\n\n          // Override the orientation with its default value\n          dataView.setUint16(_offset, 1, littleEndian);\n          break;\n        }\n      }\n    }\n  } catch (e) {\n    orientation = 1;\n  }\n  return orientation;\n}\n\n/**\n * Parse Exif Orientation value.\n * @param {number} orientation - The orientation to parse.\n * @returns {Object} The parsed result.\n */\nfunction parseOrientation(orientation) {\n  var rotate = 0;\n  var scaleX = 1;\n  var scaleY = 1;\n  switch (orientation) {\n    // Flip horizontal\n    case 2:\n      scaleX = -1;\n      break;\n\n    // Rotate left 180°\n    case 3:\n      rotate = -180;\n      break;\n\n    // Flip vertical\n    case 4:\n      scaleY = -1;\n      break;\n\n    // Flip vertical and rotate right 90°\n    case 5:\n      rotate = 90;\n      scaleY = -1;\n      break;\n\n    // Rotate right 90°\n    case 6:\n      rotate = 90;\n      break;\n\n    // Flip horizontal and rotate right 90°\n    case 7:\n      rotate = 90;\n      scaleX = -1;\n      break;\n\n    // Rotate left 90°\n    case 8:\n      rotate = -90;\n      break;\n  }\n  return {\n    rotate: rotate,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\nvar REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n\n/**\n * Normalize decimal number.\n * Check out {@link https://0.30000000000000004.com/}\n * @param {number} value - The value to normalize.\n * @param {number} [times=100000000000] - The times for normalizing.\n * @returns {number} Returns the normalized number.\n */\nfunction normalizeDecimalNumber(value) {\n  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n}\n\n/**\n * Get the max sizes in a rectangle under the given aspect ratio.\n * @param {Object} data - The original sizes.\n * @param {string} [type='contain'] - The adjust type.\n * @returns {Object} The result sizes.\n */\nfunction getAdjustedSizes(_ref) {\n  var aspectRatio = _ref.aspectRatio,\n    height = _ref.height,\n    width = _ref.width;\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'none';\n  var isValidWidth = isPositiveNumber(width);\n  var isValidHeight = isPositiveNumber(height);\n  if (isValidWidth && isValidHeight) {\n    var adjustedWidth = height * aspectRatio;\n    if ((type === 'contain' || type === 'none') && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n      height = width / aspectRatio;\n    } else {\n      width = height * aspectRatio;\n    }\n  } else if (isValidWidth) {\n    height = width / aspectRatio;\n  } else if (isValidHeight) {\n    width = height * aspectRatio;\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * Get Exif information from the given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {Array} The read Exif information.\n */\nfunction getExif(arrayBuffer) {\n  var array = toArray(new Uint8Array(arrayBuffer));\n  var length = array.length;\n  var segments = [];\n  var start = 0;\n  while (start + 3 < length) {\n    var value = array[start];\n    var next = array[start + 1];\n\n    // SOS (Start of Scan)\n    if (value === 0xFF && next === 0xDA) {\n      break;\n    }\n\n    // SOI (Start of Image)\n    if (value === 0xFF && next === 0xD8) {\n      start += 2;\n    } else {\n      var offset = array[start + 2] * 256 + array[start + 3];\n      var end = start + offset + 2;\n      var segment = array.slice(start, end);\n      segments.push(segment);\n      start = end;\n    }\n  }\n  return segments.reduce(function (exifArray, current) {\n    if (current[0] === 0xFF && current[1] === 0xE1) {\n      return exifArray.concat(current);\n    }\n    return exifArray;\n  }, []);\n}\n\n/**\n * Insert Exif information into the given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {Array} exifArray - The Exif information to insert.\n * @returns {ArrayBuffer} The transformed array buffer.\n */\nfunction insertExif(arrayBuffer, exifArray) {\n  var array = toArray(new Uint8Array(arrayBuffer));\n  if (array[2] !== 0xFF || array[3] !== 0xE0) {\n    return arrayBuffer;\n  }\n  var app0Length = array[4] * 256 + array[5];\n  var newArrayBuffer = [0xFF, 0xD8].concat(exifArray, array.slice(4 + app0Length));\n  return new Uint8Array(newArrayBuffer);\n}\n\nvar ArrayBuffer$1 = WINDOW.ArrayBuffer,\n  FileReader = WINDOW.FileReader;\nvar URL = WINDOW.URL || WINDOW.webkitURL;\nvar REGEXP_EXTENSION = /\\.\\w+$/;\nvar AnotherCompressor = WINDOW.Compressor;\n\n/**\n * Creates a new image compressor.\n * @class\n */\nvar Compressor = /*#__PURE__*/function () {\n  /**\n   * The constructor of Compressor.\n   * @param {File|Blob} file - The target image file for compressing.\n   * @param {Object} [options] - The options for compressing.\n   */\n  function Compressor(file, options) {\n    _classCallCheck(this, Compressor);\n    this.file = file;\n    this.exif = [];\n    this.image = new Image();\n    this.options = _objectSpread2(_objectSpread2({}, DEFAULTS), options);\n    this.aborted = false;\n    this.result = null;\n    this.init();\n  }\n  _createClass(Compressor, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      var file = this.file,\n        options = this.options;\n      if (!isBlob(file)) {\n        this.fail(new Error('The first argument must be a File or Blob object.'));\n        return;\n      }\n      var mimeType = file.type;\n      if (!isImageType(mimeType)) {\n        this.fail(new Error('The first argument must be an image File or Blob object.'));\n        return;\n      }\n      if (!URL || !FileReader) {\n        this.fail(new Error('The current browser does not support image compression.'));\n        return;\n      }\n      if (!ArrayBuffer$1) {\n        options.checkOrientation = false;\n        options.retainExif = false;\n      }\n      var isJPEGImage = mimeType === 'image/jpeg';\n      var checkOrientation = isJPEGImage && options.checkOrientation;\n      var retainExif = isJPEGImage && options.retainExif;\n      if (URL && !checkOrientation && !retainExif) {\n        this.load({\n          url: URL.createObjectURL(file)\n        });\n      } else {\n        var reader = new FileReader();\n        this.reader = reader;\n        reader.onload = function (_ref) {\n          var target = _ref.target;\n          var result = target.result;\n          var data = {};\n          var orientation = 1;\n          if (checkOrientation) {\n            // Reset the orientation value to its default value 1\n            // as some iOS browsers will render image with its orientation\n            orientation = resetAndGetOrientation(result);\n            if (orientation > 1) {\n              _extends(data, parseOrientation(orientation));\n            }\n          }\n          if (retainExif) {\n            _this.exif = getExif(result);\n          }\n          if (checkOrientation || retainExif) {\n            if (!URL\n\n            // Generate a new URL with the default orientation value 1.\n            || orientation > 1) {\n              data.url = arrayBufferToDataURL(result, mimeType);\n            } else {\n              data.url = URL.createObjectURL(file);\n            }\n          } else {\n            data.url = result;\n          }\n          _this.load(data);\n        };\n        reader.onabort = function () {\n          _this.fail(new Error('Aborted to read the image with FileReader.'));\n        };\n        reader.onerror = function () {\n          _this.fail(new Error('Failed to read the image with FileReader.'));\n        };\n        reader.onloadend = function () {\n          _this.reader = null;\n        };\n        if (checkOrientation || retainExif) {\n          reader.readAsArrayBuffer(file);\n        } else {\n          reader.readAsDataURL(file);\n        }\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load(data) {\n      var _this2 = this;\n      var file = this.file,\n        image = this.image;\n      image.onload = function () {\n        _this2.draw(_objectSpread2(_objectSpread2({}, data), {}, {\n          naturalWidth: image.naturalWidth,\n          naturalHeight: image.naturalHeight\n        }));\n      };\n      image.onabort = function () {\n        _this2.fail(new Error('Aborted to load the image.'));\n      };\n      image.onerror = function () {\n        _this2.fail(new Error('Failed to load the image.'));\n      };\n\n      // Match all browsers that use WebKit as the layout engine in iOS devices,\n      // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n      if (WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent)) {\n        // Fix the `The operation is insecure` error (#57)\n        image.crossOrigin = 'anonymous';\n      }\n      image.alt = file.name;\n      image.src = data.url;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var _this3 = this;\n      var naturalWidth = _ref2.naturalWidth,\n        naturalHeight = _ref2.naturalHeight,\n        _ref2$rotate = _ref2.rotate,\n        rotate = _ref2$rotate === void 0 ? 0 : _ref2$rotate,\n        _ref2$scaleX = _ref2.scaleX,\n        scaleX = _ref2$scaleX === void 0 ? 1 : _ref2$scaleX,\n        _ref2$scaleY = _ref2.scaleY,\n        scaleY = _ref2$scaleY === void 0 ? 1 : _ref2$scaleY;\n      var file = this.file,\n        image = this.image,\n        options = this.options;\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var is90DegreesRotated = Math.abs(rotate) % 180 === 90;\n      var resizable = (options.resize === 'contain' || options.resize === 'cover') && isPositiveNumber(options.width) && isPositiveNumber(options.height);\n      var maxWidth = Math.max(options.maxWidth, 0) || Infinity;\n      var maxHeight = Math.max(options.maxHeight, 0) || Infinity;\n      var minWidth = Math.max(options.minWidth, 0) || 0;\n      var minHeight = Math.max(options.minHeight, 0) || 0;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var width = options.width,\n        height = options.height;\n      if (is90DegreesRotated) {\n        var _ref3 = [maxHeight, maxWidth];\n        maxWidth = _ref3[0];\n        maxHeight = _ref3[1];\n        var _ref4 = [minHeight, minWidth];\n        minWidth = _ref4[0];\n        minHeight = _ref4[1];\n        var _ref5 = [height, width];\n        width = _ref5[0];\n        height = _ref5[1];\n      }\n      if (resizable) {\n        aspectRatio = width / height;\n      }\n      var _getAdjustedSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: maxWidth,\n        height: maxHeight\n      }, 'contain');\n      maxWidth = _getAdjustedSizes.width;\n      maxHeight = _getAdjustedSizes.height;\n      var _getAdjustedSizes2 = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: minWidth,\n        height: minHeight\n      }, 'cover');\n      minWidth = _getAdjustedSizes2.width;\n      minHeight = _getAdjustedSizes2.height;\n      if (resizable) {\n        var _getAdjustedSizes3 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: width,\n          height: height\n        }, options.resize);\n        width = _getAdjustedSizes3.width;\n        height = _getAdjustedSizes3.height;\n      } else {\n        var _getAdjustedSizes4 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: width,\n          height: height\n        });\n        var _getAdjustedSizes4$wi = _getAdjustedSizes4.width;\n        width = _getAdjustedSizes4$wi === void 0 ? naturalWidth : _getAdjustedSizes4$wi;\n        var _getAdjustedSizes4$he = _getAdjustedSizes4.height;\n        height = _getAdjustedSizes4$he === void 0 ? naturalHeight : _getAdjustedSizes4$he;\n      }\n      width = Math.floor(normalizeDecimalNumber(Math.min(Math.max(width, minWidth), maxWidth)));\n      height = Math.floor(normalizeDecimalNumber(Math.min(Math.max(height, minHeight), maxHeight)));\n      var destX = -width / 2;\n      var destY = -height / 2;\n      var destWidth = width;\n      var destHeight = height;\n      var params = [];\n      if (resizable) {\n        var srcX = 0;\n        var srcY = 0;\n        var srcWidth = naturalWidth;\n        var srcHeight = naturalHeight;\n        var _getAdjustedSizes5 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: naturalWidth,\n          height: naturalHeight\n        }, {\n          contain: 'cover',\n          cover: 'contain'\n        }[options.resize]);\n        srcWidth = _getAdjustedSizes5.width;\n        srcHeight = _getAdjustedSizes5.height;\n        srcX = (naturalWidth - srcWidth) / 2;\n        srcY = (naturalHeight - srcHeight) / 2;\n        params.push(srcX, srcY, srcWidth, srcHeight);\n      }\n      params.push(destX, destY, destWidth, destHeight);\n      if (is90DegreesRotated) {\n        var _ref6 = [height, width];\n        width = _ref6[0];\n        height = _ref6[1];\n      }\n      canvas.width = width;\n      canvas.height = height;\n      if (!isImageType(options.mimeType)) {\n        options.mimeType = file.type;\n      }\n      var fillStyle = 'transparent';\n\n      // Converts PNG files over the `convertSize` to JPEGs.\n      if (file.size > options.convertSize && options.convertTypes.indexOf(options.mimeType) >= 0) {\n        options.mimeType = 'image/jpeg';\n      }\n      var isJPEGImage = options.mimeType === 'image/jpeg';\n      if (isJPEGImage) {\n        fillStyle = '#fff';\n      }\n\n      // Override the default fill color (#000, black)\n      context.fillStyle = fillStyle;\n      context.fillRect(0, 0, width, height);\n      if (options.beforeDraw) {\n        options.beforeDraw.call(this, context, canvas);\n      }\n      if (this.aborted) {\n        return;\n      }\n      context.save();\n      context.translate(width / 2, height / 2);\n      context.rotate(rotate * Math.PI / 180);\n      context.scale(scaleX, scaleY);\n      context.drawImage.apply(context, [image].concat(params));\n      context.restore();\n      if (options.drew) {\n        options.drew.call(this, context, canvas);\n      }\n      if (this.aborted) {\n        return;\n      }\n      var callback = function callback(blob) {\n        if (!_this3.aborted) {\n          var done = function done(result) {\n            return _this3.done({\n              naturalWidth: naturalWidth,\n              naturalHeight: naturalHeight,\n              result: result\n            });\n          };\n          if (blob && isJPEGImage && options.retainExif && _this3.exif && _this3.exif.length > 0) {\n            var next = function next(arrayBuffer) {\n              return done(toBlob(arrayBufferToDataURL(insertExif(arrayBuffer, _this3.exif), options.mimeType)));\n            };\n            if (blob.arrayBuffer) {\n              blob.arrayBuffer().then(next).catch(function () {\n                _this3.fail(new Error('Failed to read the compressed image with Blob.arrayBuffer().'));\n              });\n            } else {\n              var reader = new FileReader();\n              _this3.reader = reader;\n              reader.onload = function (_ref7) {\n                var target = _ref7.target;\n                next(target.result);\n              };\n              reader.onabort = function () {\n                _this3.fail(new Error('Aborted to read the compressed image with FileReader.'));\n              };\n              reader.onerror = function () {\n                _this3.fail(new Error('Failed to read the compressed image with FileReader.'));\n              };\n              reader.onloadend = function () {\n                _this3.reader = null;\n              };\n              reader.readAsArrayBuffer(blob);\n            }\n          } else {\n            done(blob);\n          }\n        }\n      };\n      if (canvas.toBlob) {\n        canvas.toBlob(callback, options.mimeType, options.quality);\n      } else {\n        callback(toBlob(canvas.toDataURL(options.mimeType, options.quality)));\n      }\n    }\n  }, {\n    key: \"done\",\n    value: function done(_ref8) {\n      var naturalWidth = _ref8.naturalWidth,\n        naturalHeight = _ref8.naturalHeight,\n        result = _ref8.result;\n      var file = this.file,\n        image = this.image,\n        options = this.options;\n      if (URL && image.src.indexOf('blob:') === 0) {\n        URL.revokeObjectURL(image.src);\n      }\n      if (result) {\n        // Returns original file if the result is greater than it and without size related options\n        if (options.strict && !options.retainExif && result.size > file.size && options.mimeType === file.type && !(options.width > naturalWidth || options.height > naturalHeight || options.minWidth > naturalWidth || options.minHeight > naturalHeight || options.maxWidth < naturalWidth || options.maxHeight < naturalHeight)) {\n          result = file;\n        } else {\n          var date = new Date();\n          result.lastModified = date.getTime();\n          result.lastModifiedDate = date;\n          result.name = file.name;\n\n          // Convert the extension to match its type\n          if (result.name && result.type !== file.type) {\n            result.name = result.name.replace(REGEXP_EXTENSION, imageTypeToExtension(result.type));\n          }\n        }\n      } else {\n        // Returns original file if the result is null in some cases.\n        result = file;\n      }\n      this.result = result;\n      if (options.success) {\n        options.success.call(this, result);\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(err) {\n      var options = this.options;\n      if (options.error) {\n        options.error.call(this, err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (!this.aborted) {\n        this.aborted = true;\n        if (this.reader) {\n          this.reader.abort();\n        } else if (!this.image.complete) {\n          this.image.onload = null;\n          this.image.onabort();\n        } else {\n          this.fail(new Error('The compression process has been aborted.'));\n        }\n      }\n    }\n\n    /**\n     * Get the no conflict compressor class.\n     * @returns {Compressor} The compressor class.\n     */\n  }], [{\n    key: \"noConflict\",\n    value: function noConflict() {\n      window.Compressor = AnotherCompressor;\n      return Compressor;\n    }\n\n    /**\n     * Change the default options.\n     * @param {Object} options - The new default options.\n     */\n  }, {\n    key: \"setDefaults\",\n    value: function setDefaults(options) {\n      _extends(DEFAULTS, options);\n    }\n  }]);\n  return Compressor;\n}();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tcHJlc3NvcmpzL2Rpc3QvY29tcHJlc3Nvci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFZ0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSFBcXE9uZURyaXZlXFxEZXNrdG9wXFxFZHVQcmVzc1xcZWR1cHJlc3NcXG5vZGVfbW9kdWxlc1xcY29tcHJlc3NvcmpzXFxkaXN0XFxjb21wcmVzc29yLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvbXByZXNzb3IuanMgdjEuMi4xXG4gKiBodHRwczovL2Zlbmd5dWFuY2hlbi5naXRodWIuaW8vY29tcHJlc3NvcmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTgtcHJlc2VudCBDaGVuIEZlbmd5dWFuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTAyLTI4VDE0OjA5OjQxLjczMlpcbiAqL1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBjYW52YXNUb0Jsb2IgPSB7ZXhwb3J0czoge319O1xuXG4vKlxuICogSmF2YVNjcmlwdCBDYW52YXMgdG8gQmxvYlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1DYW52YXMtdG8tQmxvYlxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvbiBzdGFja292ZXJmbG93IHVzZXIgU3RvaXZlJ3MgY29kZSBzbmlwcGV0OlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNDk5ODkwOFxuICovXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgKGZ1bmN0aW9uICh3aW5kb3cpIHtcblxuICAgIHZhciBDYW52YXNQcm90b3R5cGUgPSB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgJiYgd2luZG93LkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZTtcbiAgICB2YXIgaGFzQmxvYkNvbnN0cnVjdG9yID0gd2luZG93LkJsb2IgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obmV3IEJsb2IoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIGhhc0FycmF5QnVmZmVyVmlld1N1cHBvcnQgPSBoYXNCbG9iQ29uc3RydWN0b3IgJiYgd2luZG93LlVpbnQ4QXJyYXkgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtuZXcgVWludDhBcnJheSgxMDApXSkuc2l6ZSA9PT0gMTAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuICAgIHZhciBkYXRhVVJJUGF0dGVybiA9IC9eZGF0YTooKC4qPykoO2NoYXJzZXQ9Lio/KT8pKDtiYXNlNjQpPywvO1xuICAgIHZhciBkYXRhVVJMdG9CbG9iID0gKGhhc0Jsb2JDb25zdHJ1Y3RvciB8fCBCbG9iQnVpbGRlcikgJiYgd2luZG93LmF0b2IgJiYgd2luZG93LkFycmF5QnVmZmVyICYmIHdpbmRvdy5VaW50OEFycmF5ICYmIGZ1bmN0aW9uIChkYXRhVVJJKSB7XG4gICAgICB2YXIgbWF0Y2hlcywgbWVkaWFUeXBlLCBpc0Jhc2U2NCwgZGF0YVN0cmluZywgYnl0ZVN0cmluZywgYXJyYXlCdWZmZXIsIGludEFycmF5LCBpLCBiYjtcbiAgICAgIC8vIFBhcnNlIHRoZSBkYXRhVVJJIGNvbXBvbmVudHMgYXMgcGVyIFJGQyAyMzk3XG4gICAgICBtYXRjaGVzID0gZGF0YVVSSS5tYXRjaChkYXRhVVJJUGF0dGVybik7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEgVVJJJyk7XG4gICAgICB9XG4gICAgICAvLyBEZWZhdWx0IHRvIHRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSVxuICAgICAgbWVkaWFUeXBlID0gbWF0Y2hlc1syXSA/IG1hdGNoZXNbMV0gOiAndGV4dC9wbGFpbicgKyAobWF0Y2hlc1szXSB8fCAnO2NoYXJzZXQ9VVMtQVNDSUknKTtcbiAgICAgIGlzQmFzZTY0ID0gISFtYXRjaGVzWzRdO1xuICAgICAgZGF0YVN0cmluZyA9IGRhdGFVUkkuc2xpY2UobWF0Y2hlc1swXS5sZW5ndGgpO1xuICAgICAgaWYgKGlzQmFzZTY0KSB7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nOlxuICAgICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhU3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0L1VSTEVuY29kZWQgZGF0YSBjb21wb25lbnQgdG8gcmF3IGJpbmFyeTpcbiAgICAgICAgYnl0ZVN0cmluZyA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIC8vIFdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyOlxuICAgICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgICAgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdyaXRlIHRoZSBBcnJheUJ1ZmZlciAob3IgQXJyYXlCdWZmZXJWaWV3KSB0byBhIGJsb2I6XG4gICAgICBpZiAoaGFzQmxvYkNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbaGFzQXJyYXlCdWZmZXJWaWV3U3VwcG9ydCA/IGludEFycmF5IDogYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgICAgdHlwZTogbWVkaWFUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gYmIuZ2V0QmxvYihtZWRpYVR5cGUpO1xuICAgIH07XG4gICAgaWYgKHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCAmJiAhQ2FudmFzUHJvdG90eXBlLnRvQmxvYikge1xuICAgICAgaWYgKENhbnZhc1Byb3RvdHlwZS5tb3pHZXRBc0ZpbGUpIHtcbiAgICAgICAgQ2FudmFzUHJvdG90eXBlLnRvQmxvYiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdHlwZSwgcXVhbGl0eSkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChxdWFsaXR5ICYmIENhbnZhc1Byb3RvdHlwZS50b0RhdGFVUkwgJiYgZGF0YVVSTHRvQmxvYikge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhVVJMdG9CbG9iKHNlbGYudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLm1vekdldEFzRmlsZSgnYmxvYicsIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoQ2FudmFzUHJvdG90eXBlLnRvRGF0YVVSTCAmJiBkYXRhVVJMdG9CbG9iKSB7XG4gICAgICAgIGlmIChDYW52YXNQcm90b3R5cGUubXNUb0Jsb2IpIHtcbiAgICAgICAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCh0eXBlICYmIHR5cGUgIT09ICdpbWFnZS9wbmcnIHx8IHF1YWxpdHkpICYmIENhbnZhc1Byb3RvdHlwZS50b0RhdGFVUkwgJiYgZGF0YVVSTHRvQmxvYikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFVUkx0b0Jsb2Ioc2VsZi50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLm1zVG9CbG9iKHR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YVVSTHRvQmxvYihzZWxmLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZGF0YVVSTHRvQmxvYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRhdGFVUkx0b0Jsb2IgPSBkYXRhVVJMdG9CbG9iO1xuICAgIH1cbiAgfSkod2luZG93KTtcbn0pKGNhbnZhc1RvQmxvYik7XG52YXIgdG9CbG9iID0gY2FudmFzVG9CbG9iLmV4cG9ydHM7XG5cbnZhciBpc0Jsb2IgPSBmdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCbG9iIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn07XG5cbnZhciBERUZBVUxUUyA9IHtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiBvdXRwdXQgdGhlIG9yaWdpbmFsIGltYWdlIGluc3RlYWQgb2YgdGhlIGNvbXByZXNzZWQgb25lXG4gICAqIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbXByZXNzZWQgaW1hZ2UgaXMgZ3JlYXRlciB0aGFuIHRoZSBvcmlnaW5hbCBvbmUnc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0cmljdDogdHJ1ZSxcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiByZWFkIHRoZSBpbWFnZSdzIEV4aWYgT3JpZW50YXRpb24gaW5mb3JtYXRpb24sXG4gICAqIGFuZCB0aGVuIHJvdGF0ZSBvciBmbGlwIHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNoZWNrT3JpZW50YXRpb246IHRydWUsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgcmV0YWluIHRoZSBpbWFnZSdzIEV4aWYgaW5mb3JtYXRpb24gYWZ0ZXIgY29tcHJlc3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICovXG4gIHJldGFpbkV4aWY6IGZhbHNlLFxuICAvKipcbiAgICogVGhlIG1heCB3aWR0aCBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbWF4V2lkdGg6IEluZmluaXR5LFxuICAvKipcbiAgICogVGhlIG1heCBoZWlnaHQgb2YgdGhlIG91dHB1dCBpbWFnZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1heEhlaWdodDogSW5maW5pdHksXG4gIC8qKlxuICAgKiBUaGUgbWluIHdpZHRoIG9mIHRoZSBvdXRwdXQgaW1hZ2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtaW5XaWR0aDogMCxcbiAgLyoqXG4gICAqIFRoZSBtaW4gaGVpZ2h0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtaW5IZWlnaHQ6IDAsXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIG91dHB1dCBpbWFnZS5cbiAgICogSWYgbm90IHNwZWNpZmllZCwgdGhlIG5hdHVyYWwgd2lkdGggb2YgdGhlIHNvdXJjZSBpbWFnZSB3aWxsIGJlIHVzZWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB3aWR0aDogdW5kZWZpbmVkLFxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgbmF0dXJhbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbWFnZSB3aWxsIGJlIHVzZWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgLyoqXG4gICAqIFNldHMgaG93IHRoZSBzaXplIG9mIHRoZSBpbWFnZSBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgY29udGFpbmVyXG4gICAqIHNwZWNpZmllZCBieSB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgb3B0aW9ucy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHJlc2l6ZTogJ25vbmUnLFxuICAvKipcbiAgICogVGhlIHF1YWxpdHkgb2YgdGhlIG91dHB1dCBpbWFnZS5cbiAgICogSXQgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgYDFgLFxuICAgKiBhbmQgb25seSBhdmFpbGFibGUgZm9yIGBpbWFnZS9qcGVnYCBhbmQgYGltYWdlL3dlYnBgIGltYWdlcy5cbiAgICogQ2hlY2sgb3V0IHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIGNhbnZhcy50b0Jsb2J9LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgcXVhbGl0eTogMC44LFxuICAvKipcbiAgICogVGhlIG1pbWUgdHlwZSBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgb3JpZ2luYWwgbWltZSB0eXBlIG9mIHRoZSBzb3VyY2UgaW1hZ2UgZmlsZSB3aWxsIGJlIHVzZWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBtaW1lVHlwZTogJ2F1dG8nLFxuICAvKipcbiAgICogRmlsZXMgd2hvc2UgZmlsZSB0eXBlIGlzIGluY2x1ZGVkIGluIHRoaXMgbGlzdCxcbiAgICogYW5kIHdob3NlIGZpbGUgc2l6ZSBleGNlZWRzIHRoZSBgY29udmVydFNpemVgIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIHRvIEpQRUdzLlxuICAgKiBAdHlwZSB7c3RyaW5n772cQXJyYXl9XG4gICAqL1xuICBjb252ZXJ0VHlwZXM6IFsnaW1hZ2UvcG5nJ10sXG4gIC8qKlxuICAgKiBQTkcgZmlsZXMgb3ZlciB0aGlzIHNpemUgKDUgTUIgYnkgZGVmYXVsdCkgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gSlBFR3MuXG4gICAqIFRvIGRpc2FibGUgdGhpcywganVzdCBzZXQgdGhlIHZhbHVlIHRvIGBJbmZpbml0eWAuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBjb252ZXJ0U2l6ZTogNTAwMDAwMCxcbiAgLyoqXG4gICAqIFRoZSBob29rIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYmVmb3JlIGRyYXcgdGhlIGltYWdlIGludG8gdGhlIGNhbnZhcyBmb3IgY29tcHJlc3Npb24uXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgMmQgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyBmb3IgY29tcHJlc3Npb24uXG4gICAqIEBleGFtcGxlXG4gICAqIGZ1bmN0aW9uIChjb250ZXh0LCBjYW52YXMpIHtcbiAgICogICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZmZmJztcbiAgICogfVxuICAgKi9cbiAgYmVmb3JlRHJhdzogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBob29rIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgZHJldyB0aGUgaW1hZ2UgaW50byB0aGUgY2FudmFzIGZvciBjb21wcmVzc2lvbi5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSAyZCByZW5kZXJpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZvciBjb21wcmVzc2lvbi5cbiAgICogQGV4YW1wbGVcbiAgICogZnVuY3Rpb24gKGNvbnRleHQsIGNhbnZhcykge1xuICAgKiAgIGNvbnRleHQuZmlsdGVyID0gJ2dyYXlzY2FsZSgxMDAlKSc7XG4gICAqIH1cbiAgICovXG4gIGRyZXc6IG51bGwsXG4gIC8qKlxuICAgKiBUaGUgaG9vayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gc3VjY2VzcyB0byBjb21wcmVzcyB0aGUgaW1hZ2UuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIC0gVGhlIGNvbXByZXNzZWQgaW1hZ2UgRmlsZSBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAqICAgY29uc29sZS5sb2coZmlsZSk7XG4gICAqIH1cbiAgICovXG4gIHN1Y2Nlc3M6IG51bGwsXG4gIC8qKlxuICAgKiBUaGUgaG9vayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gZmFpbCB0byBjb21wcmVzcyB0aGUgaW1hZ2UuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gQW4gRXJyb3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xuICAgKiB9XG4gICAqL1xuICBlcnJvcjogbnVsbFxufTtcblxudmFyIElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBXSU5ET1cgPSBJU19CUk9XU0VSID8gd2luZG93IDoge307XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcG9zaXRpdmUgbnVtYmVyLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqL1xudmFyIGlzUG9zaXRpdmVOdW1iZXIgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA+IDAgJiYgdmFsdWUgPCBJbmZpbml0eTtcbn07XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9yIGl0ZXJhYmxlIG9iamVjdCB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbSA/IEFycmF5LmZyb20odmFsdWUpIDogc2xpY2UuY2FsbCh2YWx1ZSk7XG59XG52YXIgUkVHRVhQX0lNQUdFX1RZUEUgPSAvXmltYWdlXFwvLiskLztcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBtaW1lIHR5cGUgb2YgaW1hZ2UuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpcyBhIG1pbWUgdHlwZSBvZiBpbWFnZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ltYWdlVHlwZSh2YWx1ZSkge1xuICByZXR1cm4gUkVHRVhQX0lNQUdFX1RZUEUudGVzdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydCBpbWFnZSB0eXBlIHRvIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbWFnZSB0eXBlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0aGUgaW1hZ2UgZXh0ZW5zaW9uLlxuICovXG5mdW5jdGlvbiBpbWFnZVR5cGVUb0V4dGVuc2lvbih2YWx1ZSkge1xuICB2YXIgZXh0ZW5zaW9uID0gaXNJbWFnZVR5cGUodmFsdWUpID8gdmFsdWUuc3Vic3RyKDYpIDogJyc7XG4gIGlmIChleHRlbnNpb24gPT09ICdqcGVnJykge1xuICAgIGV4dGVuc2lvbiA9ICdqcGcnO1xuICB9XG4gIHJldHVybiBcIi5cIi5jb25jYXQoZXh0ZW5zaW9uKTtcbn1cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKipcbiAqIEdldCBzdHJpbmcgZnJvbSBjaGFyIGNvZGUgaW4gZGF0YSB2aWV3LlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgLSBUaGUgZGF0YSB2aWV3IGZvciByZWFkLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSByZWFkIGxlbmd0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZWFkIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBzdGFydCwgbGVuZ3RoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIGk7XG4gIGxlbmd0aCArPSBzdGFydDtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHN0ciArPSBmcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG52YXIgYnRvYSA9IFdJTkRPVy5idG9hO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcnJheSBidWZmZXIgdG8gRGF0YSBVUkwuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIC0gVGhlIG1pbWUgdHlwZSBvZiB0aGUgRGF0YSBVUkwuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IERhdGEgVVJMLlxuICovXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvRGF0YVVSTChhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgdmFyIGNodW5rcyA9IFtdO1xuICB2YXIgY2h1bmtTaXplID0gODE5MjtcbiAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICB3aGlsZSAodWludDgubGVuZ3RoID4gMCkge1xuICAgIC8vIFhYWDogQmFiZWwncyBgdG9Db25zdW1hYmxlQXJyYXlgIGhlbHBlciB3aWxsIHRocm93IGVycm9yIGluIElFIG9yIFNhZmFyaSA5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICBjaHVua3MucHVzaChmcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdG9BcnJheSh1aW50OC5zdWJhcnJheSgwLCBjaHVua1NpemUpKSkpO1xuICAgIHVpbnQ4ID0gdWludDguc3ViYXJyYXkoY2h1bmtTaXplKTtcbiAgfVxuICByZXR1cm4gXCJkYXRhOlwiLmNvbmNhdChtaW1lVHlwZSwgXCI7YmFzZTY0LFwiKS5jb25jYXQoYnRvYShjaHVua3Muam9pbignJykpKTtcbn1cblxuLyoqXG4gKiBHZXQgb3JpZW50YXRpb24gdmFsdWUgZnJvbSBnaXZlbiBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIgdG8gcmVhZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZWFkIG9yaWVudGF0aW9uIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZXNldEFuZEdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKSB7XG4gIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIHZhciBvcmllbnRhdGlvbjtcblxuICAvLyBJZ25vcmVzIHJhbmdlIGVycm9yIHdoZW4gdGhlIGltYWdlIGRvZXMgbm90IGhhdmUgY29ycmVjdCBFeGlmIGluZm9ybWF0aW9uXG4gIHRyeSB7XG4gICAgdmFyIGxpdHRsZUVuZGlhbjtcbiAgICB2YXIgYXBwMVN0YXJ0O1xuICAgIHZhciBpZmRTdGFydDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIEpQRUcgaW1hZ2UgKHN0YXJ0IGJ5IDB4RkZEOClcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgoMCkgPT09IDB4RkYgJiYgZGF0YVZpZXcuZ2V0VWludDgoMSkgPT09IDB4RDgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIG9mZnNldCA9IDI7XG4gICAgICB3aGlsZSAob2Zmc2V0ICsgMSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSA9PT0gMHhGRiAmJiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKSA9PT0gMHhFMSkge1xuICAgICAgICAgIGFwcDFTdGFydCA9IG9mZnNldDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcDFTdGFydCkge1xuICAgICAgdmFyIGV4aWZJRENvZGUgPSBhcHAxU3RhcnQgKyA0O1xuICAgICAgdmFyIHRpZmZPZmZzZXQgPSBhcHAxU3RhcnQgKyAxMDtcbiAgICAgIGlmIChnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIGV4aWZJRENvZGUsIDQpID09PSAnRXhpZicpIHtcbiAgICAgICAgdmFyIGVuZGlhbm5lc3MgPSBkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCk7XG4gICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuZGlhbm5lc3MgPT09IDB4NDk0OTtcbiAgICAgICAgaWYgKGxpdHRsZUVuZGlhbiB8fCBlbmRpYW5uZXNzID09PSAweDRENEQgLyogYmlnRW5kaWFuICovKSB7XG4gICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMDJBKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RJRkRPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPj0gMHgwMDAwMDAwOCkge1xuICAgICAgICAgICAgICBpZmRTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlmZFN0YXJ0KSB7XG4gICAgICB2YXIgX2xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihpZmRTdGFydCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgIHZhciBfb2Zmc2V0O1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgX2xlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIF9vZmZzZXQgPSBpZmRTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMTEyIC8qIE9yaWVudGF0aW9uICovKSB7XG4gICAgICAgICAgLy8gOCBpcyB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHRhZydzIHZhbHVlXG4gICAgICAgICAgX29mZnNldCArPSA4O1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgICAgICAgIG9yaWVudGF0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KF9vZmZzZXQsIGxpdHRsZUVuZGlhbik7XG5cbiAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgb3JpZW50YXRpb24gd2l0aCBpdHMgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihfb2Zmc2V0LCAxLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgb3JpZW50YXRpb24gPSAxO1xuICB9XG4gIHJldHVybiBvcmllbnRhdGlvbjtcbn1cblxuLyoqXG4gKiBQYXJzZSBFeGlmIE9yaWVudGF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0gVGhlIG9yaWVudGF0aW9uIHRvIHBhcnNlLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgdmFyIHJvdGF0ZSA9IDA7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcbiAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgIC8vIEZsaXAgaG9yaXpvbnRhbFxuICAgIGNhc2UgMjpcbiAgICAgIHNjYWxlWCA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBSb3RhdGUgbGVmdCAxODDCsFxuICAgIGNhc2UgMzpcbiAgICAgIHJvdGF0ZSA9IC0xODA7XG4gICAgICBicmVhaztcblxuICAgIC8vIEZsaXAgdmVydGljYWxcbiAgICBjYXNlIDQ6XG4gICAgICBzY2FsZVkgPSAtMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gRmxpcCB2ZXJ0aWNhbCBhbmQgcm90YXRlIHJpZ2h0IDkwwrBcbiAgICBjYXNlIDU6XG4gICAgICByb3RhdGUgPSA5MDtcbiAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBSb3RhdGUgcmlnaHQgOTDCsFxuICAgIGNhc2UgNjpcbiAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBGbGlwIGhvcml6b250YWwgYW5kIHJvdGF0ZSByaWdodCA5MMKwXG4gICAgY2FzZSA3OlxuICAgICAgcm90YXRlID0gOTA7XG4gICAgICBzY2FsZVggPSAtMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gUm90YXRlIGxlZnQgOTDCsFxuICAgIGNhc2UgODpcbiAgICAgIHJvdGF0ZSA9IC05MDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgcm90YXRlOiByb3RhdGUsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cbnZhciBSRUdFWFBfREVDSU1BTFMgPSAvXFwuXFxkKig/OjB8OSl7MTJ9XFxkKiQvO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBkZWNpbWFsIG51bWJlci5cbiAqIENoZWNrIG91dCB7QGxpbmsgaHR0cHM6Ly8wLjMwMDAwMDAwMDAwMDAwMDA0LmNvbS99XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lcz0xMDAwMDAwMDAwMDBdIC0gVGhlIHRpbWVzIGZvciBub3JtYWxpemluZy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEZWNpbWFsTnVtYmVyKHZhbHVlKSB7XG4gIHZhciB0aW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDAwMDAwMDAwO1xuICByZXR1cm4gUkVHRVhQX0RFQ0lNQUxTLnRlc3QodmFsdWUpID8gTWF0aC5yb3VuZCh2YWx1ZSAqIHRpbWVzKSAvIHRpbWVzIDogdmFsdWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtYXggc2l6ZXMgaW4gYSByZWN0YW5nbGUgdW5kZXIgdGhlIGdpdmVuIGFzcGVjdCByYXRpby5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG9yaWdpbmFsIHNpemVzLlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPSdjb250YWluJ10gLSBUaGUgYWRqdXN0IHR5cGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IHNpemVzLlxuICovXG5mdW5jdGlvbiBnZXRBZGp1c3RlZFNpemVzKF9yZWYpIHtcbiAgdmFyIGFzcGVjdFJhdGlvID0gX3JlZi5hc3BlY3RSYXRpbyxcbiAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICB3aWR0aCA9IF9yZWYud2lkdGg7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnbm9uZSc7XG4gIHZhciBpc1ZhbGlkV2lkdGggPSBpc1Bvc2l0aXZlTnVtYmVyKHdpZHRoKTtcbiAgdmFyIGlzVmFsaWRIZWlnaHQgPSBpc1Bvc2l0aXZlTnVtYmVyKGhlaWdodCk7XG4gIGlmIChpc1ZhbGlkV2lkdGggJiYgaXNWYWxpZEhlaWdodCkge1xuICAgIHZhciBhZGp1c3RlZFdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgaWYgKCh0eXBlID09PSAnY29udGFpbicgfHwgdHlwZSA9PT0gJ25vbmUnKSAmJiBhZGp1c3RlZFdpZHRoID4gd2lkdGggfHwgdHlwZSA9PT0gJ2NvdmVyJyAmJiBhZGp1c3RlZFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRXaWR0aCkge1xuICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEhlaWdodCkge1xuICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgRXhpZiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIgdG8gcmVhZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlYWQgRXhpZiBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RXhpZihhcnJheUJ1ZmZlcikge1xuICB2YXIgYXJyYXkgPSB0b0FycmF5KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBzZWdtZW50cyA9IFtdO1xuICB2YXIgc3RhcnQgPSAwO1xuICB3aGlsZSAoc3RhcnQgKyAzIDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbc3RhcnRdO1xuICAgIHZhciBuZXh0ID0gYXJyYXlbc3RhcnQgKyAxXTtcblxuICAgIC8vIFNPUyAoU3RhcnQgb2YgU2NhbilcbiAgICBpZiAodmFsdWUgPT09IDB4RkYgJiYgbmV4dCA9PT0gMHhEQSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gU09JIChTdGFydCBvZiBJbWFnZSlcbiAgICBpZiAodmFsdWUgPT09IDB4RkYgJiYgbmV4dCA9PT0gMHhEOCkge1xuICAgICAgc3RhcnQgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldCA9IGFycmF5W3N0YXJ0ICsgMl0gKiAyNTYgKyBhcnJheVtzdGFydCArIDNdO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgb2Zmc2V0ICsgMjtcbiAgICAgIHZhciBzZWdtZW50ID0gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGV4aWZBcnJheSwgY3VycmVudCkge1xuICAgIGlmIChjdXJyZW50WzBdID09PSAweEZGICYmIGN1cnJlbnRbMV0gPT09IDB4RTEpIHtcbiAgICAgIHJldHVybiBleGlmQXJyYXkuY29uY2F0KGN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZXhpZkFycmF5O1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IEV4aWYgaW5mb3JtYXRpb24gaW50byB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgLSBUaGUgYXJyYXkgYnVmZmVyIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXl9IGV4aWZBcnJheSAtIFRoZSBFeGlmIGluZm9ybWF0aW9uIHRvIGluc2VydC5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIHRyYW5zZm9ybWVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0RXhpZihhcnJheUJ1ZmZlciwgZXhpZkFycmF5KSB7XG4gIHZhciBhcnJheSA9IHRvQXJyYXkobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgaWYgKGFycmF5WzJdICE9PSAweEZGIHx8IGFycmF5WzNdICE9PSAweEUwKSB7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG4gIHZhciBhcHAwTGVuZ3RoID0gYXJyYXlbNF0gKiAyNTYgKyBhcnJheVs1XTtcbiAgdmFyIG5ld0FycmF5QnVmZmVyID0gWzB4RkYsIDB4RDhdLmNvbmNhdChleGlmQXJyYXksIGFycmF5LnNsaWNlKDQgKyBhcHAwTGVuZ3RoKSk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShuZXdBcnJheUJ1ZmZlcik7XG59XG5cbnZhciBBcnJheUJ1ZmZlciQxID0gV0lORE9XLkFycmF5QnVmZmVyLFxuICBGaWxlUmVhZGVyID0gV0lORE9XLkZpbGVSZWFkZXI7XG52YXIgVVJMID0gV0lORE9XLlVSTCB8fCBXSU5ET1cud2Via2l0VVJMO1xudmFyIFJFR0VYUF9FWFRFTlNJT04gPSAvXFwuXFx3KyQvO1xudmFyIEFub3RoZXJDb21wcmVzc29yID0gV0lORE9XLkNvbXByZXNzb3I7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbWFnZSBjb21wcmVzc29yLlxuICogQGNsYXNzXG4gKi9cbnZhciBDb21wcmVzc29yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBvZiBDb21wcmVzc29yLlxuICAgKiBAcGFyYW0ge0ZpbGV8QmxvYn0gZmlsZSAtIFRoZSB0YXJnZXQgaW1hZ2UgZmlsZSBmb3IgY29tcHJlc3NpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucyBmb3IgY29tcHJlc3NpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBDb21wcmVzc29yKGZpbGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcHJlc3Nvcik7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLmV4aWYgPSBbXTtcbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdGhpcy5vcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRTKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhDb21wcmVzc29yLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGUsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIWlzQmxvYihmaWxlKSkge1xuICAgICAgICB0aGlzLmZhaWwobmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIEZpbGUgb3IgQmxvYiBvYmplY3QuJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWltZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICBpZiAoIWlzSW1hZ2VUeXBlKG1pbWVUeXBlKSkge1xuICAgICAgICB0aGlzLmZhaWwobmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbWFnZSBGaWxlIG9yIEJsb2Igb2JqZWN0LicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFVUkwgfHwgIUZpbGVSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5mYWlsKG5ldyBFcnJvcignVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGltYWdlIGNvbXByZXNzaW9uLicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheUJ1ZmZlciQxKSB7XG4gICAgICAgIG9wdGlvbnMuY2hlY2tPcmllbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnJldGFpbkV4aWYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0pQRUdJbWFnZSA9IG1pbWVUeXBlID09PSAnaW1hZ2UvanBlZyc7XG4gICAgICB2YXIgY2hlY2tPcmllbnRhdGlvbiA9IGlzSlBFR0ltYWdlICYmIG9wdGlvbnMuY2hlY2tPcmllbnRhdGlvbjtcbiAgICAgIHZhciByZXRhaW5FeGlmID0gaXNKUEVHSW1hZ2UgJiYgb3B0aW9ucy5yZXRhaW5FeGlmO1xuICAgICAgaWYgKFVSTCAmJiAhY2hlY2tPcmllbnRhdGlvbiAmJiAhcmV0YWluRXhpZikge1xuICAgICAgICB0aGlzLmxvYWQoe1xuICAgICAgICAgIHVybDogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IF9yZWYudGFyZ2V0O1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQucmVzdWx0O1xuICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gMTtcbiAgICAgICAgICBpZiAoY2hlY2tPcmllbnRhdGlvbikge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIG9yaWVudGF0aW9uIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIDFcbiAgICAgICAgICAgIC8vIGFzIHNvbWUgaU9TIGJyb3dzZXJzIHdpbGwgcmVuZGVyIGltYWdlIHdpdGggaXRzIG9yaWVudGF0aW9uXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9IHJlc2V0QW5kR2V0T3JpZW50YXRpb24ocmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgX2V4dGVuZHMoZGF0YSwgcGFyc2VPcmllbnRhdGlvbihvcmllbnRhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmV0YWluRXhpZikge1xuICAgICAgICAgICAgX3RoaXMuZXhpZiA9IGdldEV4aWYocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrT3JpZW50YXRpb24gfHwgcmV0YWluRXhpZikge1xuICAgICAgICAgICAgaWYgKCFVUkxcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgVVJMIHdpdGggdGhlIGRlZmF1bHQgb3JpZW50YXRpb24gdmFsdWUgMS5cbiAgICAgICAgICAgIHx8IG9yaWVudGF0aW9uID4gMSkge1xuICAgICAgICAgICAgICBkYXRhLnVybCA9IGFycmF5QnVmZmVyVG9EYXRhVVJMKHJlc3VsdCwgbWltZVR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YS51cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnVybCA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMubG9hZChkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZmFpbChuZXcgRXJyb3IoJ0Fib3J0ZWQgdG8gcmVhZCB0aGUgaW1hZ2Ugd2l0aCBGaWxlUmVhZGVyLicpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZmFpbChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIHRoZSBpbWFnZSB3aXRoIEZpbGVSZWFkZXIuJykpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlYWRlciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGVja09yaWVudGF0aW9uIHx8IHJldGFpbkV4aWYpIHtcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGUsXG4gICAgICAgIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmRyYXcoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRhdGEpLCB7fSwge1xuICAgICAgICAgIG5hdHVyYWxXaWR0aDogaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IGltYWdlLm5hdHVyYWxIZWlnaHRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIGltYWdlLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5mYWlsKG5ldyBFcnJvcignQWJvcnRlZCB0byBsb2FkIHRoZSBpbWFnZS4nKSk7XG4gICAgICB9O1xuICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZhaWwobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCB0aGUgaW1hZ2UuJykpO1xuICAgICAgfTtcblxuICAgICAgLy8gTWF0Y2ggYWxsIGJyb3dzZXJzIHRoYXQgdXNlIFdlYktpdCBhcyB0aGUgbGF5b3V0IGVuZ2luZSBpbiBpT1MgZGV2aWNlcyxcbiAgICAgIC8vIHN1Y2ggYXMgU2FmYXJpIGZvciBpT1MsIENocm9tZSBmb3IgaU9TLCBhbmQgaW4tYXBwIGJyb3dzZXJzLlxuICAgICAgaWYgKFdJTkRPVy5uYXZpZ2F0b3IgJiYgLyg/OmlQYWR8aVBob25lfGlQb2QpLio/QXBwbGVXZWJLaXQvaS50ZXN0KFdJTkRPVy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAvLyBGaXggdGhlIGBUaGUgb3BlcmF0aW9uIGlzIGluc2VjdXJlYCBlcnJvciAoIzU3KVxuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgfVxuICAgICAgaW1hZ2UuYWx0ID0gZmlsZS5uYW1lO1xuICAgICAgaW1hZ2Uuc3JjID0gZGF0YS51cmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmMikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgbmF0dXJhbFdpZHRoID0gX3JlZjIubmF0dXJhbFdpZHRoLFxuICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gX3JlZjIubmF0dXJhbEhlaWdodCxcbiAgICAgICAgX3JlZjIkcm90YXRlID0gX3JlZjIucm90YXRlLFxuICAgICAgICByb3RhdGUgPSBfcmVmMiRyb3RhdGUgPT09IHZvaWQgMCA/IDAgOiBfcmVmMiRyb3RhdGUsXG4gICAgICAgIF9yZWYyJHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgICAgc2NhbGVYID0gX3JlZjIkc2NhbGVYID09PSB2b2lkIDAgPyAxIDogX3JlZjIkc2NhbGVYLFxuICAgICAgICBfcmVmMiRzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgIHNjYWxlWSA9IF9yZWYyJHNjYWxlWSA9PT0gdm9pZCAwID8gMSA6IF9yZWYyJHNjYWxlWTtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlLFxuICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGlzOTBEZWdyZWVzUm90YXRlZCA9IE1hdGguYWJzKHJvdGF0ZSkgJSAxODAgPT09IDkwO1xuICAgICAgdmFyIHJlc2l6YWJsZSA9IChvcHRpb25zLnJlc2l6ZSA9PT0gJ2NvbnRhaW4nIHx8IG9wdGlvbnMucmVzaXplID09PSAnY292ZXInKSAmJiBpc1Bvc2l0aXZlTnVtYmVyKG9wdGlvbnMud2lkdGgpICYmIGlzUG9zaXRpdmVOdW1iZXIob3B0aW9ucy5oZWlnaHQpO1xuICAgICAgdmFyIG1heFdpZHRoID0gTWF0aC5tYXgob3B0aW9ucy5tYXhXaWR0aCwgMCkgfHwgSW5maW5pdHk7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gTWF0aC5tYXgob3B0aW9ucy5tYXhIZWlnaHQsIDApIHx8IEluZmluaXR5O1xuICAgICAgdmFyIG1pbldpZHRoID0gTWF0aC5tYXgob3B0aW9ucy5taW5XaWR0aCwgMCkgfHwgMDtcbiAgICAgIHZhciBtaW5IZWlnaHQgPSBNYXRoLm1heChvcHRpb25zLm1pbkhlaWdodCwgMCkgfHwgMDtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgIGlmIChpczkwRGVncmVlc1JvdGF0ZWQpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gW21heEhlaWdodCwgbWF4V2lkdGhdO1xuICAgICAgICBtYXhXaWR0aCA9IF9yZWYzWzBdO1xuICAgICAgICBtYXhIZWlnaHQgPSBfcmVmM1sxXTtcbiAgICAgICAgdmFyIF9yZWY0ID0gW21pbkhlaWdodCwgbWluV2lkdGhdO1xuICAgICAgICBtaW5XaWR0aCA9IF9yZWY0WzBdO1xuICAgICAgICBtaW5IZWlnaHQgPSBfcmVmNFsxXTtcbiAgICAgICAgdmFyIF9yZWY1ID0gW2hlaWdodCwgd2lkdGhdO1xuICAgICAgICB3aWR0aCA9IF9yZWY1WzBdO1xuICAgICAgICBoZWlnaHQgPSBfcmVmNVsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNpemFibGUpIHtcbiAgICAgICAgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICAgIH0sICdjb250YWluJyk7XG4gICAgICBtYXhXaWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoO1xuICAgICAgbWF4SGVpZ2h0ID0gX2dldEFkanVzdGVkU2l6ZXMuaGVpZ2h0O1xuICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzMiA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBtaW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBtaW5IZWlnaHRcbiAgICAgIH0sICdjb3ZlcicpO1xuICAgICAgbWluV2lkdGggPSBfZ2V0QWRqdXN0ZWRTaXplczIud2lkdGg7XG4gICAgICBtaW5IZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplczIuaGVpZ2h0O1xuICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9LCBvcHRpb25zLnJlc2l6ZSk7XG4gICAgICAgIHdpZHRoID0gX2dldEFkanVzdGVkU2l6ZXMzLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplczMuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzNCA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplczQkd2kgPSBfZ2V0QWRqdXN0ZWRTaXplczQud2lkdGg7XG4gICAgICAgIHdpZHRoID0gX2dldEFkanVzdGVkU2l6ZXM0JHdpID09PSB2b2lkIDAgPyBuYXR1cmFsV2lkdGggOiBfZ2V0QWRqdXN0ZWRTaXplczQkd2k7XG4gICAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplczQkaGUgPSBfZ2V0QWRqdXN0ZWRTaXplczQuaGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplczQkaGUgPT09IHZvaWQgMCA/IG5hdHVyYWxIZWlnaHQgOiBfZ2V0QWRqdXN0ZWRTaXplczQkaGU7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3Iobm9ybWFsaXplRGVjaW1hbE51bWJlcihNYXRoLm1pbihNYXRoLm1heCh3aWR0aCwgbWluV2lkdGgpLCBtYXhXaWR0aCkpKTtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3Iobm9ybWFsaXplRGVjaW1hbE51bWJlcihNYXRoLm1pbihNYXRoLm1heChoZWlnaHQsIG1pbkhlaWdodCksIG1heEhlaWdodCkpKTtcbiAgICAgIHZhciBkZXN0WCA9IC13aWR0aCAvIDI7XG4gICAgICB2YXIgZGVzdFkgPSAtaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBkZXN0V2lkdGggPSB3aWR0aDtcbiAgICAgIHZhciBkZXN0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICB2YXIgc3JjWCA9IDA7XG4gICAgICAgIHZhciBzcmNZID0gMDtcbiAgICAgICAgdmFyIHNyY1dpZHRoID0gbmF0dXJhbFdpZHRoO1xuICAgICAgICB2YXIgc3JjSGVpZ2h0ID0gbmF0dXJhbEhlaWdodDtcbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzNSA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgICB3aWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogbmF0dXJhbEhlaWdodFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY29udGFpbjogJ2NvdmVyJyxcbiAgICAgICAgICBjb3ZlcjogJ2NvbnRhaW4nXG4gICAgICAgIH1bb3B0aW9ucy5yZXNpemVdKTtcbiAgICAgICAgc3JjV2lkdGggPSBfZ2V0QWRqdXN0ZWRTaXplczUud2lkdGg7XG4gICAgICAgIHNyY0hlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzNS5oZWlnaHQ7XG4gICAgICAgIHNyY1ggPSAobmF0dXJhbFdpZHRoIC0gc3JjV2lkdGgpIC8gMjtcbiAgICAgICAgc3JjWSA9IChuYXR1cmFsSGVpZ2h0IC0gc3JjSGVpZ2h0KSAvIDI7XG4gICAgICAgIHBhcmFtcy5wdXNoKHNyY1gsIHNyY1ksIHNyY1dpZHRoLCBzcmNIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcGFyYW1zLnB1c2goZGVzdFgsIGRlc3RZLCBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpO1xuICAgICAgaWYgKGlzOTBEZWdyZWVzUm90YXRlZCkge1xuICAgICAgICB2YXIgX3JlZjYgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgIHdpZHRoID0gX3JlZjZbMF07XG4gICAgICAgIGhlaWdodCA9IF9yZWY2WzFdO1xuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFpc0ltYWdlVHlwZShvcHRpb25zLm1pbWVUeXBlKSkge1xuICAgICAgICBvcHRpb25zLm1pbWVUeXBlID0gZmlsZS50eXBlO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGxTdHlsZSA9ICd0cmFuc3BhcmVudCc7XG5cbiAgICAgIC8vIENvbnZlcnRzIFBORyBmaWxlcyBvdmVyIHRoZSBgY29udmVydFNpemVgIHRvIEpQRUdzLlxuICAgICAgaWYgKGZpbGUuc2l6ZSA+IG9wdGlvbnMuY29udmVydFNpemUgJiYgb3B0aW9ucy5jb252ZXJ0VHlwZXMuaW5kZXhPZihvcHRpb25zLm1pbWVUeXBlKSA+PSAwKSB7XG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSAnaW1hZ2UvanBlZyc7XG4gICAgICB9XG4gICAgICB2YXIgaXNKUEVHSW1hZ2UgPSBvcHRpb25zLm1pbWVUeXBlID09PSAnaW1hZ2UvanBlZyc7XG4gICAgICBpZiAoaXNKUEVHSW1hZ2UpIHtcbiAgICAgICAgZmlsbFN0eWxlID0gJyNmZmYnO1xuICAgICAgfVxuXG4gICAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBmaWxsIGNvbG9yICgjMDAwLCBibGFjaylcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGlmIChvcHRpb25zLmJlZm9yZURyYXcpIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVEcmF3LmNhbGwodGhpcywgY29udGV4dCwgY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgY29udGV4dC5yb3RhdGUocm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICBjb250ZXh0LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlLmFwcGx5KGNvbnRleHQsIFtpbWFnZV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICBpZiAob3B0aW9ucy5kcmV3KSB7XG4gICAgICAgIG9wdGlvbnMuZHJldy5jYWxsKHRoaXMsIGNvbnRleHQsIGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGJsb2IpIHtcbiAgICAgICAgaWYgKCFfdGhpczMuYWJvcnRlZCkge1xuICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZG9uZSh7XG4gICAgICAgICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoYmxvYiAmJiBpc0pQRUdJbWFnZSAmJiBvcHRpb25zLnJldGFpbkV4aWYgJiYgX3RoaXMzLmV4aWYgJiYgX3RoaXMzLmV4aWYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb25lKHRvQmxvYihhcnJheUJ1ZmZlclRvRGF0YVVSTChpbnNlcnRFeGlmKGFycmF5QnVmZmVyLCBfdGhpczMuZXhpZiksIG9wdGlvbnMubWltZVR5cGUpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGJsb2IuYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4obmV4dCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5mYWlsKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgdGhlIGNvbXByZXNzZWQgaW1hZ2Ugd2l0aCBCbG9iLmFycmF5QnVmZmVyKCkuJykpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICBfdGhpczMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9yZWY3LnRhcmdldDtcbiAgICAgICAgICAgICAgICBuZXh0KHRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuZmFpbChuZXcgRXJyb3IoJ0Fib3J0ZWQgdG8gcmVhZCB0aGUgY29tcHJlc3NlZCBpbWFnZSB3aXRoIEZpbGVSZWFkZXIuJykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuZmFpbChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIHRoZSBjb21wcmVzc2VkIGltYWdlIHdpdGggRmlsZVJlYWRlci4nKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnJlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZShibG9iKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgICAgICBjYW52YXMudG9CbG9iKGNhbGxiYWNrLCBvcHRpb25zLm1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodG9CbG9iKGNhbnZhcy50b0RhdGFVUkwob3B0aW9ucy5taW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbmUoX3JlZjgpIHtcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSBfcmVmOC5uYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfcmVmOC5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICByZXN1bHQgPSBfcmVmOC5yZXN1bHQ7XG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZSxcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKFVSTCAmJiBpbWFnZS5zcmMuaW5kZXhPZignYmxvYjonKSA9PT0gMCkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGltYWdlLnNyYyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIFJldHVybnMgb3JpZ2luYWwgZmlsZSBpZiB0aGUgcmVzdWx0IGlzIGdyZWF0ZXIgdGhhbiBpdCBhbmQgd2l0aG91dCBzaXplIHJlbGF0ZWQgb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3QgJiYgIW9wdGlvbnMucmV0YWluRXhpZiAmJiByZXN1bHQuc2l6ZSA+IGZpbGUuc2l6ZSAmJiBvcHRpb25zLm1pbWVUeXBlID09PSBmaWxlLnR5cGUgJiYgIShvcHRpb25zLndpZHRoID4gbmF0dXJhbFdpZHRoIHx8IG9wdGlvbnMuaGVpZ2h0ID4gbmF0dXJhbEhlaWdodCB8fCBvcHRpb25zLm1pbldpZHRoID4gbmF0dXJhbFdpZHRoIHx8IG9wdGlvbnMubWluSGVpZ2h0ID4gbmF0dXJhbEhlaWdodCB8fCBvcHRpb25zLm1heFdpZHRoIDwgbmF0dXJhbFdpZHRoIHx8IG9wdGlvbnMubWF4SGVpZ2h0IDwgbmF0dXJhbEhlaWdodCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICByZXN1bHQubGFzdE1vZGlmaWVkID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgcmVzdWx0Lmxhc3RNb2RpZmllZERhdGUgPSBkYXRlO1xuICAgICAgICAgIHJlc3VsdC5uYW1lID0gZmlsZS5uYW1lO1xuXG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgZXh0ZW5zaW9uIHRvIG1hdGNoIGl0cyB0eXBlXG4gICAgICAgICAgaWYgKHJlc3VsdC5uYW1lICYmIHJlc3VsdC50eXBlICE9PSBmaWxlLnR5cGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUucmVwbGFjZShSRUdFWFBfRVhURU5TSU9OLCBpbWFnZVR5cGVUb0V4dGVuc2lvbihyZXN1bHQudHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJucyBvcmlnaW5hbCBmaWxlIGlmIHRoZSByZXN1bHQgaXMgbnVsbCBpbiBzb21lIGNhc2VzLlxuICAgICAgICByZXN1bHQgPSBmaWxlO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgIG9wdGlvbnMuc3VjY2Vzcy5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFpbChlcnIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgb3B0aW9ucy5lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgaWYgKCF0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucmVhZGVyKSB7XG4gICAgICAgICAgdGhpcy5yZWFkZXIuYWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmltYWdlLm9uYWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZhaWwobmV3IEVycm9yKCdUaGUgY29tcHJlc3Npb24gcHJvY2VzcyBoYXMgYmVlbiBhYm9ydGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm8gY29uZmxpY3QgY29tcHJlc3NvciBjbGFzcy5cbiAgICAgKiBAcmV0dXJucyB7Q29tcHJlc3Nvcn0gVGhlIGNvbXByZXNzb3IgY2xhc3MuXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJub0NvbmZsaWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICB3aW5kb3cuQ29tcHJlc3NvciA9IEFub3RoZXJDb21wcmVzc29yO1xuICAgICAgcmV0dXJuIENvbXByZXNzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbmV3IGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICBfZXh0ZW5kcyhERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb21wcmVzc29yO1xufSgpO1xuXG5leHBvcnQgeyBDb21wcmVzc29yIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/compressorjs/dist/compressor.esm.js\n");

/***/ })

};
;